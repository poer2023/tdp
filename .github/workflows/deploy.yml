# Automated deployment workflow triggered after Docker Build completes
name: Auto Deploy

on:
  workflow_run:
    workflows: ["Docker Build and Push"]
    types:
      - completed
    branches:
      - main
  workflow_dispatch:
    inputs:
      environment:
        description: "Deploy environment"
        required: true
        default: "production"
        type: choice
        options:
          - production
          - staging

jobs:
  deploy:
    name: Deploy to Server
    runs-on: ubuntu-latest
    # Allow manual dispatch anytime; for auto runs, only proceed if the build succeeded
    # and the commit message does not contain [skip deploy]
    if: >-
      ${{ github.event_name == 'workflow_dispatch' ||
          (github.event.workflow_run.conclusion == 'success' &&
           !contains(github.event.workflow_run.head_commit.message, '[skip deploy]')) }}
    concurrency: deploy-${{ github.ref }}
    # Require environment approval for production deployments. Configure in
    # Settings â†’ Environments â†’ production to add required reviewers.
    environment: production
    env:
      GHCR_USERNAME: ${{ secrets.GHCR_USERNAME }}
      GHCR_TOKEN: ${{ secrets.GHCR_TOKEN }}
      SSH_HOST: ${{ secrets.SSH_HOST }}
      SSH_PORT: ${{ secrets.SSH_PORT }}
      SSH_USER: ${{ secrets.SSH_USER }}
      PROJECT_DIR: ${{ secrets.PROJECT_DIR }}
      GIT_URL: ${{ github.server_url }}/${{ github.repository }}.git
      BRANCH: main

      # Environment variables for .env generation
      # Core infrastructure (database, auth, encryption)
      ENV_CREDENTIAL_ENCRYPTION_KEY: ${{ secrets.ENV_CREDENTIAL_ENCRYPTION_KEY }}
      ENV_DATABASE_URL: ${{ secrets.ENV_DATABASE_URL }}
      ENV_NEXTAUTH_SECRET: ${{ secrets.ENV_NEXTAUTH_SECRET }}
      ENV_NEXTAUTH_URL: ${{ secrets.ENV_NEXTAUTH_URL }}
      ENV_GOOGLE_CLIENT_ID: ${{ secrets.ENV_GOOGLE_CLIENT_ID }}
      ENV_GOOGLE_CLIENT_SECRET: ${{ secrets.ENV_GOOGLE_CLIENT_SECRET }}
      ENV_ADMIN_EMAILS: ${{ secrets.ENV_ADMIN_EMAILS }}
      ENV_MAX_UPLOAD_SIZE_MB: ${{ secrets.ENV_MAX_UPLOAD_SIZE_MB }}
      ENV_ADMIN_API_KEY: ${{ secrets.ENV_ADMIN_API_KEY }}
      ENV_CRON_SECRET: ${{ secrets.ENV_CRON_SECRET }}
      ENV_FRIEND_JWT_SECRET: ${{ secrets.ENV_FRIEND_JWT_SECRET }}

      # Feature flags (default values, can be overridden on server)
      ENV_FEATURE_ADMIN_CREDENTIALS: ${{ secrets.ENV_FEATURE_ADMIN_CREDENTIALS }}
      ENV_FEATURE_ADMIN_ANALYTICS: ${{ secrets.ENV_FEATURE_ADMIN_ANALYTICS }}
      ENV_FEATURE_ADMIN_GALLERY: ${{ secrets.ENV_FEATURE_ADMIN_GALLERY }}
      ENV_FEATURE_ADMIN_POSTS: ${{ secrets.ENV_FEATURE_ADMIN_POSTS }}
      ENV_FEATURE_ADMIN_SYNC: ${{ secrets.ENV_FEATURE_ADMIN_SYNC }}
      ENV_FEATURE_ADMIN_EXPORT: ${{ secrets.ENV_FEATURE_ADMIN_EXPORT }}
      ENV_FEATURE_ADMIN_DASHBOARD: ${{ secrets.ENV_FEATURE_ADMIN_DASHBOARD }}

      # Maintenance API token for post-deploy tasks
      MAINTENANCE_API_TOKEN: ${{ secrets.MAINTENANCE_API_TOKEN }}

      # Apple Health steps sync token
      ENV_HEALTH_SYNC_TOKEN: ${{ secrets.ENV_HEALTH_SYNC_TOKEN }}

    steps:
      - name: Verify CI and Docker Build Status
        shell: bash
        run: |
          set -euo pipefail

          EVENT_NAME="${{ github.event_name }}"
          REPO="${{ github.repository }}"

          NEED_DOCKER_CHECK="true"
          if [[ "$EVENT_NAME" == "workflow_run" ]]; then
            COMMIT_SHA="${{ github.event.workflow_run.head_sha }}"
            RUN_ID="${{ github.event.workflow_run.id }}"
          elif [[ "$EVENT_NAME" == "workflow_dispatch" ]]; then
            COMMIT_SHA="${{ github.sha }}"
            NEED_DOCKER_CHECK="false"
          else
            COMMIT_SHA="${{ github.sha }}"
          fi

          echo "Checking workflow status for commit: $COMMIT_SHA in $REPO (event: $EVENT_NAME)"

          # Check CI Critical Path status with retries to allow CI to finish
          MAX_CI_CHECKS=24 # ~4 minutes with 10s interval
          CI_RUN_STATUS=""
          CI_CONCLUSION=""
          for attempt in $(seq 1 "$MAX_CI_CHECKS"); do
            CI_JSON=$(gh run list \
              --repo="$REPO" \
              --workflow="ci.yml" \
              --commit="$COMMIT_SHA" \
              --limit 1 \
              --json status,conclusion)

            CI_RUN_STATUS=$(echo "$CI_JSON" | jq -r '.[0].status // empty')
            CI_CONCLUSION=$(echo "$CI_JSON" | jq -r '.[0].conclusion // empty')

            if [[ -z "${CI_RUN_STATUS}" ]]; then
              echo "Attempt ${attempt}/${MAX_CI_CHECKS}: CI Critical Path run not found yet. Waiting..."
            elif [[ "$CI_RUN_STATUS" != "completed" ]]; then
              echo "Attempt ${attempt}/${MAX_CI_CHECKS}: CI Critical Path status is ${CI_RUN_STATUS}. Waiting for completion..."
            else
              break
            fi
            sleep 10
          done

          if [[ -z "${CI_RUN_STATUS}" || "$CI_RUN_STATUS" != "completed" ]]; then
            echo "Unable to determine CI Critical Path status for commit $COMMIT_SHA after ${MAX_CI_CHECKS} attempts" >&2
            exit 1
          fi

          if [[ -z "${CI_CONCLUSION}" || "${CI_CONCLUSION}" == "null" ]]; then
            echo "CI Critical Path conclusion missing for commit $COMMIT_SHA" >&2
            exit 1
          fi

          if [[ "$CI_CONCLUSION" != "success" ]]; then
            echo "âŒ CI Critical Path did not succeed: $CI_CONCLUSION"
            echo "Cannot deploy when CI checks fail"
            exit 1
          fi
          echo "âœ… CI Critical Path: $CI_CONCLUSION"

          if [[ "$NEED_DOCKER_CHECK" != "true" ]]; then
            echo "Docker build status check skipped for manual dispatch."
            exit 0
          fi

          if [[ -z "${RUN_ID:-}" ]]; then
            echo "âŒ Unable to determine Docker Build workflow run ID for commit $COMMIT_SHA" >&2
            exit 1
          fi

          DOCKER_BUILD_STATUS=$(gh run view \
            --repo="$REPO" \
            "$RUN_ID" \
            --json jobs \
            --jq '.jobs[] | select(.name == "build") | .conclusion')

          if [[ -z "${DOCKER_BUILD_STATUS:-}" ]]; then
            echo "âŒ Unable to determine Docker Build job status for run $RUN_ID" >&2
            exit 1
          fi

          if [[ "$DOCKER_BUILD_STATUS" != "success" ]]; then
            echo "âŒ Docker Build job status: ${DOCKER_BUILD_STATUS:-skipped}"
            echo "Cannot deploy without successful Docker image build"
            exit 1
          fi
          echo "âœ… Docker Build job: $DOCKER_BUILD_STATUS"

          echo "All pre-deployment checks passed"
        env:
          GH_TOKEN: ${{ github.token }}

      - name: Check required deploy secrets
        shell: bash
        env:
          HAS_SSH_KEY: ${{ secrets.SSH_KEY != '' }}
        run: |
          set -euo pipefail
          missing=()
          [[ -n "${SSH_HOST:-}" ]] || missing+=(SSH_HOST)
          [[ -n "${SSH_USER:-}" ]] || missing+=(SSH_USER)
          [[ "${HAS_SSH_KEY}" == "true" ]] || missing+=(SSH_KEY)
          [[ -n "${PROJECT_DIR:-}" ]] || missing+=(PROJECT_DIR)
          if (( ${#missing[@]} > 0 )); then
            echo "Missing required secrets: ${missing[*]}" >&2
            echo "Add them in Settings â†’ Secrets and variables â†’ Actions." >&2
            exit 1
          fi

      - name: Deploy to server via SSH
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.SSH_HOST }}
          port: ${{ secrets.SSH_PORT || '22' }}
          username: ${{ secrets.SSH_USER }}
          key: ${{ secrets.SSH_KEY }}
          script_stop: true
          # Pulling images and running migrations can exceed the default 10m command timeout
          command_timeout: 30m
          envs: GHCR_USERNAME,GHCR_TOKEN,GIT_URL,BRANCH,PROJECT_DIR,ENV_CREDENTIAL_ENCRYPTION_KEY,ENV_DATABASE_URL,ENV_NEXTAUTH_SECRET,ENV_NEXTAUTH_URL,ENV_GOOGLE_CLIENT_ID,ENV_GOOGLE_CLIENT_SECRET,ENV_ADMIN_EMAILS,ENV_MAX_UPLOAD_SIZE_MB,ENV_ADMIN_API_KEY,ENV_CRON_SECRET,ENV_FRIEND_JWT_SECRET,ENV_FEATURE_ADMIN_CREDENTIALS,ENV_FEATURE_ADMIN_ANALYTICS,ENV_FEATURE_ADMIN_GALLERY,ENV_FEATURE_ADMIN_POSTS,ENV_FEATURE_ADMIN_SYNC,ENV_FEATURE_ADMIN_EXPORT,ENV_FEATURE_ADMIN_DASHBOARD,ENV_HEALTH_SYNC_TOKEN
          script: |
            # Be strict on errors but do not fail on unset vars to simplify secret handling
            set -eo pipefail
            echo "DEBUG: BRANCH=${BRANCH:-} PROJECT_DIR=${PROJECT_DIR:-} GHCR_USER_SET=$([ -n "${GHCR_USERNAME:-}" ] && echo 1 || echo 0) GHCR_TOKEN_SET=$([ -n "${GHCR_TOKEN:-}" ] && echo 1 || echo 0)"

            # Ensure Docker and Compose exist
            if ! command -v docker >/dev/null 2>&1; then
              echo "Docker is not installed on the server. Please install Docker and the compose plugin." >&2
              exit 1
            fi
            if ! docker compose version >/dev/null 2>&1; then
              echo "Docker Compose plugin not found. Please install docker-compose-plugin." >&2
              exit 1
            fi

            # First-time setup: clone repository if PROJECT_DIR is not a git repo
            if [ ! -d "${PROJECT_DIR}/.git" ]; then
              echo "==> First-time setup: cloning repo into ${PROJECT_DIR}"
              if [ -d "${PROJECT_DIR}" ] && [ "$(ls -A "${PROJECT_DIR}" 2>/dev/null | wc -l)" -gt 0 ]; then
                echo "Directory exists and is not empty. Backing up to ${PROJECT_DIR}.bak-$(date +%s)"
                mv "${PROJECT_DIR}" "${PROJECT_DIR}.bak-$(date +%s)"
              fi
              mkdir -p "${PROJECT_DIR}"
              git clone --depth 1 --branch "${BRANCH}" "${GIT_URL}" "${PROJECT_DIR}"
            fi

            cd "${PROJECT_DIR}"
            # Ensure origin URL is correct and sync to remote HEAD robustly
            if git rev-parse --git-dir >/dev/null 2>&1; then
              git remote set-url origin "${GIT_URL}" || true
              git fetch origin "${BRANCH}" --depth 1 || true
              git checkout -B "${BRANCH}" "origin/${BRANCH}" 2>/dev/null || git checkout "${BRANCH}" || true
              git reset --hard "origin/${BRANCH}" || true
            fi

            # Generate .env file with hybrid strategy:
            # - Core infrastructure from GitHub Secrets (always updated)
            # - Feature flags: GitHub Secrets defaults, server .env can override
            # - Sync credentials: Managed via /admin/credentials web UI (not in .env)
            echo "==> Generating .env file (hybrid mode)"

            # Validate critical variables
            if [ -z "${ENV_DATABASE_URL:-}" ]; then
              echo "âŒ ENV_DATABASE_URL not set in GitHub Secrets" >&2
              echo "   This is required for database backups and migrations" >&2
              exit 1
            fi
            if [ -z "${ENV_CREDENTIAL_ENCRYPTION_KEY:-}" ]; then
              echo "âŒ ENV_CREDENTIAL_ENCRYPTION_KEY not set in GitHub Secrets" >&2
              exit 1
            fi
            if [ "${#ENV_CREDENTIAL_ENCRYPTION_KEY}" -ne 64 ]; then
              echo "âŒ ENV_CREDENTIAL_ENCRYPTION_KEY must be 64 hex chars" >&2
              exit 1
            fi

            # Backup existing feature flags if .env exists
            if [ -f .env ]; then
              echo "==> Backing up existing feature flags from server .env"
              FEATURE_ADMIN_CREDENTIALS_OLD=$(grep '^FEATURE_ADMIN_CREDENTIALS=' .env 2>/dev/null | cut -d= -f2 || echo "")
              FEATURE_ADMIN_ANALYTICS_OLD=$(grep '^FEATURE_ADMIN_ANALYTICS=' .env 2>/dev/null | cut -d= -f2 || echo "")
              FEATURE_ADMIN_GALLERY_OLD=$(grep '^FEATURE_ADMIN_GALLERY=' .env 2>/dev/null | cut -d= -f2 || echo "")
              FEATURE_ADMIN_POSTS_OLD=$(grep '^FEATURE_ADMIN_POSTS=' .env 2>/dev/null | cut -d= -f2 || echo "")
              FEATURE_ADMIN_SYNC_OLD=$(grep '^FEATURE_ADMIN_SYNC=' .env 2>/dev/null | cut -d= -f2 || echo "")
              FEATURE_ADMIN_EXPORT_OLD=$(grep '^FEATURE_ADMIN_EXPORT=' .env 2>/dev/null | cut -d= -f2 || echo "")
              FEATURE_ADMIN_DASHBOARD_OLD=$(grep '^FEATURE_ADMIN_DASHBOARD=' .env 2>/dev/null | cut -d= -f2 || echo "")
            fi

            # Determine feature flag values: server override OR GitHub Secrets default OR "on"
            FEATURE_ADMIN_CREDENTIALS_FINAL="${FEATURE_ADMIN_CREDENTIALS_OLD:-${ENV_FEATURE_ADMIN_CREDENTIALS:-on}}"
            FEATURE_ADMIN_ANALYTICS_FINAL="${FEATURE_ADMIN_ANALYTICS_OLD:-${ENV_FEATURE_ADMIN_ANALYTICS:-on}}"
            FEATURE_ADMIN_GALLERY_FINAL="${FEATURE_ADMIN_GALLERY_OLD:-${ENV_FEATURE_ADMIN_GALLERY:-on}}"
            FEATURE_ADMIN_POSTS_FINAL="${FEATURE_ADMIN_POSTS_OLD:-${ENV_FEATURE_ADMIN_POSTS:-on}}"
            FEATURE_ADMIN_SYNC_FINAL="${FEATURE_ADMIN_SYNC_OLD:-${ENV_FEATURE_ADMIN_SYNC:-on}}"
            FEATURE_ADMIN_EXPORT_FINAL="${FEATURE_ADMIN_EXPORT_OLD:-${ENV_FEATURE_ADMIN_EXPORT:-on}}"
            FEATURE_ADMIN_DASHBOARD_FINAL="${FEATURE_ADMIN_DASHBOARD_OLD:-${ENV_FEATURE_ADMIN_DASHBOARD:-on}}"

            # Generate core infrastructure section from GitHub Secrets
            {
              printf '%s\n' "# ============================================================================"
              printf '%s\n' "# Core Infrastructure Configuration (from GitHub Secrets)"
              printf '%s\n\n' "# ============================================================================"

              printf '%s\n' "# PostgreSQL æ•°æ®åº“è¿žæŽ¥"
              printf '%s\n\n' "DATABASE_URL=${ENV_DATABASE_URL}"

              printf '%s\n' "# NextAuth é…ç½®"
              printf '%s\n' "NEXTAUTH_URL=${ENV_NEXTAUTH_URL}"
              printf '%s\n' "# NextAuth v5 æ ‡å‡†é…ç½® (2025 æœ€ä½³å®žè·µ)"
              printf '%s\n' "AUTH_SECRET=${ENV_NEXTAUTH_SECRET}"
              printf '%s\n' "# å‘åŽå…¼å®¹"
              printf '%s\n\n' "NEXTAUTH_SECRET=${ENV_NEXTAUTH_SECRET}"

              printf '%s\n' "# Google OAuth å‡­æ®"
              printf '%s\n' "GOOGLE_CLIENT_ID=${ENV_GOOGLE_CLIENT_ID}"
              printf '%s\n\n' "GOOGLE_CLIENT_SECRET=${ENV_GOOGLE_CLIENT_SECRET}"

              printf '%s\n' "# ç®¡ç†å‘˜é…ç½®"
              printf '%s\n' "ADMIN_EMAILS=${ENV_ADMIN_EMAILS}"
              printf '%s\n\n' "MAX_UPLOAD_SIZE_MB=${ENV_MAX_UPLOAD_SIZE_MB:-10}"

              printf '%s\n' "# å‡­æ®åŠ å¯†å¯†é’¥ (AES-256-GCM) - ç”¨äºŽåŠ å¯†æ•°æ®åº“ä¸­çš„ç¬¬ä¸‰æ–¹ API å‡­æ®"
              printf '%s\n\n' "CREDENTIAL_ENCRYPTION_KEY=${ENV_CREDENTIAL_ENCRYPTION_KEY}"

              printf '%s\n' "# API å®‰å…¨å¯†é’¥"
              printf '%s\n\n' "ADMIN_API_KEY=${ENV_ADMIN_API_KEY}"
              printf '%s\n\n' "CRON_SECRET=${ENV_CRON_SECRET}"

              printf '%s\n' "# æœ‹å‹è®¤è¯ JWT å¯†é’¥"
              printf '%s\n\n' "FRIEND_JWT_SECRET=${ENV_FRIEND_JWT_SECRET}"

              printf '%s\n' "# Apple Health æ­¥æ•°åŒæ­¥ Token"
              printf '%s\n\n' "HEALTH_SYNC_TOKEN=${ENV_HEALTH_SYNC_TOKEN}"

              printf '%s\n' "# ============================================================================"
              printf '%s\n' "# Feature Flags (default from GitHub Secrets, can override on server)"
              printf '%s\n\n' "# ============================================================================"

              printf '%s\n' "# å¯ç”¨ç®¡ç†å‘˜å‡­æ®ç®¡ç†åŠŸèƒ½"
              printf '%s\n\n' "FEATURE_ADMIN_CREDENTIALS=${FEATURE_ADMIN_CREDENTIALS_FINAL}"

              printf '%s\n' "# å¯ç”¨è®¿é—®åˆ†æžåŠŸèƒ½"
              printf '%s\n\n' "FEATURE_ADMIN_ANALYTICS=${FEATURE_ADMIN_ANALYTICS_FINAL}"

              printf '%s\n' "# å¯ç”¨ç›¸å†Œç®¡ç†åŠŸèƒ½"
              printf '%s\n\n' "FEATURE_ADMIN_GALLERY=${FEATURE_ADMIN_GALLERY_FINAL}"

              printf '%s\n' "# å¯ç”¨æ–‡ç« ç®¡ç†åŠŸèƒ½"
              printf '%s\n\n' "FEATURE_ADMIN_POSTS=${FEATURE_ADMIN_POSTS_FINAL}"

              printf '%s\n' "# å¯ç”¨åŒæ­¥ä»ªè¡¨æ¿"
              printf '%s\n\n' "FEATURE_ADMIN_SYNC=${FEATURE_ADMIN_SYNC_FINAL}"

              printf '%s\n' "# å¯ç”¨å†…å®¹å¯¼å‡ºå·¥å…·"
              printf '%s\n\n' "FEATURE_ADMIN_EXPORT=${FEATURE_ADMIN_EXPORT_FINAL}"

              printf '%s\n' "# å¯ç”¨ç®¡ç†ä»ªè¡¨æ¿ç»Ÿè®¡åŠŸèƒ½"
              printf '%s\n\n' "FEATURE_ADMIN_DASHBOARD=${FEATURE_ADMIN_DASHBOARD_FINAL}"

              printf '%s\n' "# ============================================================================"
              printf '%s\n' "# NOTE: Third-party API credentials (Bilibili, Douban, Steam) are managed"
              printf '%s\n' "# through the web UI at /admin/credentials and stored encrypted in database."
              printf '%s\n' "# ============================================================================"
            } > .env

            echo "âœ… .env file generated successfully (core from Secrets, feature flags hybrid)"

            # Login to GHCR if credentials are provided (for private images)
            if [ -n "${GHCR_USERNAME:-}" ] && [ -n "${GHCR_TOKEN:-}" ]; then
              echo "==> Logging into GHCR"
              echo "$GHCR_TOKEN" | docker login ghcr.io -u "$GHCR_USERNAME" --password-stdin
            else
              echo "==> Skipping GHCR login (using public images or pre-authenticated daemon)"
            fi

            echo "==> Ensuring external networks exist"
            # Create the coolify network if it doesn't exist (required for Traefik routing)
            docker network inspect coolify >/dev/null 2>&1 || docker network create coolify

            echo "==> Pulling latest Docker images"
            docker compose pull

            echo "==> Starting deployment with automatic backup and migration"
            echo "Docker Compose will handle: backup â†’ migrate â†’ app startup"
            docker compose up -d --remove-orphans

            echo "==> Checking migration container status"
            MIGRATE_EXIT_CODE=$(docker inspect tdp-migrate --format='{{.State.ExitCode}}' 2>/dev/null || echo "255")

            if [ "$MIGRATE_EXIT_CODE" != "0" ]; then
              echo "âŒ Migration container failed with exit code: $MIGRATE_EXIT_CODE"
              echo "==> Fetching migration logs..."
              docker logs tdp-migrate || true
              MIGRATION_LOGS=$(docker logs tdp-migrate 2>&1 || echo 'No logs available')

              echo "==> Starting automatic rollback..."
              # Stop all containers
              docker compose down

              # Restore from latest backup
              if ./scripts/restore-from-backup.sh; then
                echo "âœ… Database restored from backup successfully"

                # Create GitHub Issue alert
                ISSUE_TITLE="ðŸš¨ Database Migration Failed - Auto Rollback Completed"
                printf -v ISSUE_BODY $'## Migration Failure Details\n\n**Exit Code**: %s\n\n**Migration Logs**:\n```\n%s\n```\n\n**Rollback Status**: âœ… Completed - Database restored from latest backup\n\n**Next Steps**:\n1. Review migration logs above\n2. Fix migration issues locally\n3. Test migration thoroughly before re-deploying\n\n**System Status**: All containers stopped, database rolled back to pre-migration state' \
                  "$MIGRATE_EXIT_CODE" "$MIGRATION_LOGS"

                ./scripts/alert-github-issue.sh "$ISSUE_TITLE" "$ISSUE_BODY" "migration-failure,rollback-completed,urgent" || true
              else
                echo "âŒ Automatic rollback failed!"

                # Create critical alert
                ISSUE_TITLE="ðŸš¨ðŸš¨ CRITICAL: Migration Failed AND Rollback Failed"
                printf -v ISSUE_BODY $'## Critical Failure\n\nBoth migration and automatic rollback have failed. Manual intervention required immediately.\n\n**Migration Exit Code**: %s\n\n**Migration Logs**:\n```\n%s\n```\n\n**Rollback Status**: âŒ FAILED\n\n**IMMEDIATE ACTION REQUIRED**:\n1. SSH to server: `ssh user@%s`\n2. Check backup directory: `ls -lh ./backups/`\n3. Manually restore latest backup\n4. Contact DevOps team immediately' \
                  "$MIGRATE_EXIT_CODE" "$MIGRATION_LOGS" "$SSH_HOST"

                ./scripts/alert-github-issue.sh "$ISSUE_TITLE" "$ISSUE_BODY" "migration-failure,rollback-failed,critical" || true
              fi

              echo "=== Deployment ABORTED due to migration failure ==="
              exit 1
            fi

            echo "âœ… Migration completed successfully"

            echo "==> Waiting for HTTP health (port 3000) up to 300s"
            start_ts=$(date +%s)
            timeout=300
            while true; do
              # Quick HTTP probe on host port
              if curl -fsS -m 3 http://127.0.0.1:3000/api/health >/dev/null 2>&1 || wget -qO- --timeout=3 http://127.0.0.1:3000/api/health >/dev/null 2>&1; then
                echo "âœ… HTTP health endpoint is responsive"
                break
              fi

              # Show brief container status
              docker compose ps || true

              now=$(date +%s)
              if [ $((now - start_ts)) -ge $timeout ]; then
                echo "âŒ Timeout waiting for HTTP health endpoint"
                docker compose ps || true
                echo "==> Recent logs (app)"; docker compose logs --tail=200 app || true
                echo "==> Recent logs (postgres)"; docker compose logs --tail=100 postgres || true
                exit 1
              fi
              sleep 5
            done

            echo "==> Verifying container health statuses (best-effort)"
            containers=$(docker compose ps -q || true)
            if [ -n "$containers" ]; then
              docker inspect $containers --format '{{.Name}} => {{if .State.Health}}{{.State.Health.Status}}{{else}}{{.State.Status}}{{end}}' || true
            fi

            echo "==> Running post-deploy maintenance tasks (non-blocking)"
            # Wait a bit for the app to fully warm up
            sleep 10
            
            # Run maintenance tasks in subshell with error handling disabled
            # Failures here should NOT fail the deployment
            (
              set +e  # Disable exit on error for this subshell
              
              APP_URL="http://localhost:3000"
              MAINT_TOKEN="${MAINTENANCE_API_TOKEN:-}"
              
              if [ -n "$MAINT_TOKEN" ]; then
                echo "  -> Fixing duplicate gallery images..."
                curl -sf --max-time 30 -X POST "$APP_URL/api/admin/maintenance" \
                  -H "Authorization: Bearer $MAINT_TOKEN" \
                  -H "Content-Type: application/json" \
                  -d '{"action":"fix_duplicates"}' && echo " done" || echo " skipped"
                
                echo "  -> Regenerating missing thumbnails (batch 1)..."
                curl -sf --max-time 60 -X POST "$APP_URL/api/admin/maintenance" \
                  -H "Authorization: Bearer $MAINT_TOKEN" \
                  -H "Content-Type: application/json" \
                  -d '{"action":"regenerate_thumbnails","limit":100}' && echo " done" || echo " skipped"
                
                echo "  -> Checking maintenance status..."
                curl -sf --max-time 10 -X POST "$APP_URL/api/admin/maintenance" \
                  -H "Authorization: Bearer $MAINT_TOKEN" \
                  -H "Content-Type: application/json" \
                  -d '{"action":"status"}' && echo " done" || echo " skipped"
              else
                echo "  -> MAINTENANCE_API_TOKEN not set, skipping maintenance tasks"
              fi
              
              exit 0  # Always succeed
            ) || echo "  -> Maintenance tasks completed (some may have been skipped)"

            echo "==> Cleaning up unused images"
            docker image prune -f || true

  notification:
    name: Deploy Notification
    runs-on: ubuntu-latest
    needs: deploy
    if: always()

    steps:
      - name: Deployment Success
        if: needs.deploy.result == 'success'
        env:
          SSH_HOST: ${{ secrets.SSH_HOST }}
        run: |
          echo "ðŸš€ Deployment completed successfully!"
          echo "Environment: ${{ github.event.inputs.environment || 'production' }}"
          echo "Commit: ${{ github.sha }}"
          {
            echo "# âœ… Deploy Succeeded";
            echo;
            echo "- Host: ${SSH_HOST:-unknown}";
            echo "- Service: tdp-app (port 3000)";
            echo;
            echo "Try opening: http://${SSH_HOST:-<server-ip>}:3000";
            echo;
            echo "Quick checks:";
            echo "- ssh USER@${SSH_HOST:-<server-ip>} 'docker compose ps'";
            echo "- ssh USER@${SSH_HOST:-<server-ip>} 'curl -fsS http://localhost:3000/api/health'";
          } >> "$GITHUB_STEP_SUMMARY"

      - name: Deployment Failed
        if: needs.deploy.result == 'failure'
        env:
          SSH_HOST: ${{ secrets.SSH_HOST }}
        run: |
          echo "âŒ Deployment failed!"
          echo "Please check the deployment logs and server status."
          {
            echo "# âŒ Deploy Failed";
            echo;
            echo "Host: ${SSH_HOST:-unknown}";
            echo;
            echo "Try on server:";
            echo "- docker compose ps";
            echo "- docker compose logs --tail=100 app";
            echo "- curl -v http://localhost:3000/api/health";
          } >> "$GITHUB_STEP_SUMMARY"
          exit 1
