services:
  postgres:
    image: postgres:16-alpine
    container_name: tdp-postgres
    restart: unless-stopped
    environment:
      POSTGRES_USER: tdp
      POSTGRES_PASSWORD: tdp_password
      POSTGRES_DB: tdp
    volumes:
      - postgres-data:/var/lib/postgresql/data
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U tdp"]
      interval: 10s
      timeout: 5s
      retries: 5
    networks:
      - tdp-net

  # Pre-migration backup service
  # Creates a database backup before running migrations to ensure zero data loss
  # Includes backup verification to ensure backup integrity
  backup:
    image: postgres:16-alpine
    container_name: tdp-backup
    env_file:
      - .env
    volumes:
      - ./backups:/backups
    command:
      - sh
      - -c
      - |
        echo '==> Pre-migration backup starting...';
        if [ -z "$${DATABASE_URL:-}" ]; then
          echo '⚠️  DATABASE_URL not available - skipping backup';
          echo '   This is acceptable for deployments without DATABASE_URL configured';
          exit 0;
        fi;

        echo '==> Extracting database connection details...';
        DB_USER=$$(echo "$$DATABASE_URL" | sed -n 's/.*:\/\/\([^:]*\):.*/\1/p');
        DB_PASS=$$(echo "$$DATABASE_URL" | sed -n 's/.*:\/\/[^:]*:\([^@]*\)@.*/\1/p');
        DB_HOST=$$(echo "$$DATABASE_URL" | sed -n 's/.*@\([^:]*\):.*/\1/p');
        DB_PORT=$$(echo "$$DATABASE_URL" | sed -n 's/.*:\([0-9]*\)\/.*/\1/p');
        DB_NAME=$$(echo "$$DATABASE_URL" | sed -n 's/.*\/\([^?]*\).*/\1/p');

        echo "   Database: $$DB_NAME at $$DB_HOST:$$DB_PORT";

        TIMESTAMP=$$(date +%Y%m%d_%H%M%S);
        BACKUP_FILE="/backups/backup_$${TIMESTAMP}.sql.gz";

        echo '==> Creating backup...';
        mkdir -p /backups;
        export PGPASSWORD="$$DB_PASS";

        if pg_dump -h "$$DB_HOST" -p "$$DB_PORT" -U "$$DB_USER" -d "$$DB_NAME" --format=plain --no-owner --no-acl | gzip > "$$BACKUP_FILE"; then
          BACKUP_SIZE=$$(du -h "$$BACKUP_FILE" | cut -f1);
          echo "✅ Backup created: $$BACKUP_SIZE";

          echo '==> Verifying backup integrity...';
          if gunzip -t "$$BACKUP_FILE" 2>/dev/null; then
            echo "✅ Backup verified successfully: $$(basename "$$BACKUP_FILE")";
            exit 0;
          else
            echo '❌ Backup verification failed - file is corrupted';
            exit 1;
          fi;
        else
          echo '❌ Backup creation failed';
          exit 1;
        fi;
    depends_on:
      postgres:
        condition: service_healthy
    networks:
      - tdp-net
    restart: "no"

  migrate:
    # 数据库迁移服务 - 一次性运行
    # 使用 GHCR 预构建镜像，包含 Prisma CLI 和 schema
    image: ghcr.io/poer2023/tdp:${IMAGE_TAG:-latest}
    pull_policy: always
    container_name: tdp-migrate
    env_file:
      - .env
    working_dir: /app
    # 挂载 prisma 目录以确保使用最新的 schema
    volumes:
      - ./prisma:/app/prisma:ro
    command: ["sh", "-c", "npx prisma migrate deploy"]
    depends_on:
      postgres:
        condition: service_healthy
      backup:
        condition: service_completed_successfully
    networks:
      - tdp-net
    restart: "no"

  # 权限初始化容器 - 修复 Docker volume 权限问题
  # 容器运行用户(node uid=65532) 与 volume 所有者不匹配导致的写入权限问题
  init-volumes:
    image: alpine:latest
    container_name: tdp-init-volumes
    volumes:
      - uploads-data:/data
    command: >
      sh -c "
      echo '==> 初始化上传目录权限...';
      mkdir -p /data/gallery /data/covers;
      chown -R 65532:65532 /data;
      chmod -R 755 /data;
      echo '==> 权限设置完成';
      ls -la /data;
      echo '==> 目录所有者: uid=65532 (node 用户)';
      "
    restart: "no"

  app:
    # 使用 GHCR 预构建镜像；支持通过环境变量覆盖镜像标签
    image: ghcr.io/poer2023/tdp:${IMAGE_TAG:-latest}
    pull_policy: always
    container_name: tdp-app
    restart: unless-stopped
    env_file:
      - .env
    environment:
      NODE_ENV: production
      NEXTAUTH_URL: ${NEXTAUTH_URL:-https://dybzy.com}
    ports:
      - "3000:3000"
    volumes:
      - uploads-data:/app/public/uploads
    healthcheck:
      test: ["CMD-SHELL", "node /app/docker/healthcheck.js"]
      interval: 10s
      timeout: 5s
      retries: 10
      start_period: 30s
    depends_on:
      postgres:
        condition: service_healthy
      migrate:
        condition: service_completed_successfully
      init-volumes:
        condition: service_completed_successfully
    networks:
      - tdp-net
    # 如果需要本地构建，取消下面的注释
    # build:
    #   context: .
    #   dockerfile: Dockerfile

volumes:
  postgres-data:
  uploads-data:

networks:
  tdp-net:
    driver: bridge
